## `void *`란?

- `void *`는 특정한 데이터 유형을 지정하지 않은 포인터입니다.
- 다양한 유형의 주소를 저장할 수 있습니다.
- 다양한 데이터 유형을 다루는 함수나 자료 구조에 활용됩니다.

### `void *`의 특징

#### 유형 무관성
- 어떤 유형의 데이터도 가리킬 수 있습니다.
- 마치 Java의 `Object` 클래스처럼 모든 데이터 타입을 받을 수 있습니다.

#### 형 변환 필요성
- `void *`로 저장된 주소를 사용하려면 형변환을 해야 합니다.
- 명시적으로 `int *`, `char *` 등 다른 유형의 포인터로 형 변환을 해야 합니다.

#### 메모리 할당
- 메모리 동적 할당 함수인 `malloc`과 `calloc`은 메모리 공간 할당 후 `void *` 타입으로 반환됩니다.

## 파일 위치 포인터 (file postion pointer)

- 파일 위치 포인터는 현재 파일 위치(current file position)를 가리킵니다.
  - 파일 내에 읽거나 쓸 위치를 나타냅니다.
- 파일을 오픈하면 제일 처음을 가리킵니다.

### 파일 위치 포인터 이동

#### `lseek()`
- 임의의 위치로 포인터의 위치를 이동시킬 수 있습니다.
- 파일의 내용을 읽고 포인터를 이동시킬 때 사용됩니다.

## 레코드 저장

### 레코드 저장 예제

```c
write(fd, &record1, sizeof(record));
write(fd, &record2, sizeof(record));
lseek(fd, sizeof(record), SEEK_END);
write(fd, &record3, sizeof(record));
```

#### 실행 과정
1. `record1`을 작성합니다(`write()`). 파일 위치 포인터가 자동으로 이동됩니다.
2. `record2`을 작성합니다(`write()`). 파일 위치 포인터가 자동으로 이동됩니다.
3. 파일 위치 포인터를 파일의 끝(`SEEK_END`)에서 레코드 크기 만큼 이동시킵니다(`lseek()`).
4. `record3`을 작성합니다(`write()`). 파일 위치 포인터가 자동으로 이동됩니다.

## 레코드 수정

### 레코드 수정 과정

1. 파일로부터 해당 레코드를 읽어옵니다. 파일 위치 포인터는 자동으로 이동됩니다.
2. 레코드의 내용을 수정합니다.
3. 파일 위치 포인터를 레코드의 시작 위치로 이동시키고, 수정된 레코드를 파일 내에 기록합니다(원래의 위치에 기록).

## 핵심 내용 정리

- `void *`: 데이터 유형을 지정하지 않은 포인터, 다양한 유형의 주소를 저장할 수 있습니다.
- 파일 위치 포인터: 파일 내에서 현재 위치를 가리키며, `lseek()` 함수로 이동할 수 있습니다.
- 레코드 저장: `write()` 함수를 사용하여 레코드를 파일에 저장합니다.
- 레코드 수정: 레코드를 파일에서 읽어와 수정한 뒤, 원래 위치에 기록합니다. 

이런 자료를 참고했어요.
[1] 티스토리 - #36 깃(Git) - 깃허브 리드미(README) 3 : 이미지 삽입하기 (https://abled.tistory.com/40)
[2] velog - Readme.md 파일 작성법 (https://velog.io/@gmlstjq123/Readme.md-%ED%8C%8C%EC%9D%BC-%EC%9E%91%EC%84%B1%EB%B2%95)
[3] 티스토리 - 깃허브 리드미(README) 2 : 마크다운(markdown) 문법 (https://abled.tistory.com/39)
[4] 티스토리 - Github README.md 작성 방법 및 요령 - sh424 - 티스토리 (https://lsh424.tistory.com/37) 

뤼튼 사용하러 가기 > https://agent.wrtn.ai/5xb91l
